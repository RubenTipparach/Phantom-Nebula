using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using BepuPhysics;
using BepuPhysics.Collidables;
using BepuPhysics.CollisionDetection;
using BepuPhysics.Constraints;
using BepuUtilities;
using BepuUtilities.Memory;
using System.Numerics;
using System.Runtime.CompilerServices;
using Vector3 = System.Numerics.Vector3;
using XnaMathHelper = Microsoft.Xna.Framework.MathHelper;
using XnaQuaternion = Microsoft.Xna.Framework.Quaternion;

namespace FallenTribes.Game;

[System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 1)]
public struct VertexPositionNormal : IVertexType
{
    public Microsoft.Xna.Framework.Vector3 Position;
    public Microsoft.Xna.Framework.Vector3 Normal;

    public VertexPositionNormal(Microsoft.Xna.Framework.Vector3 position, Microsoft.Xna.Framework.Vector3 normal)
    {
        Position = position;
        Normal = normal;
    }

    public static readonly VertexDeclaration VertexDeclaration = new VertexDeclaration(
        new VertexElement(0, VertexElementFormat.Vector3, VertexElementUsage.Position, 0),
        new VertexElement(12, VertexElementFormat.Vector3, VertexElementUsage.Normal, 0)
    );

    VertexDeclaration IVertexType.VertexDeclaration => VertexDeclaration;
}

public class Game1 : Microsoft.Xna.Framework.Game
{
    private GraphicsDeviceManager _graphics;
    private SpriteBatch _spriteBatch;
    private BasicEffect _effect;

    // Physics
    private Simulation _simulation;
    private BufferPool _bufferPool;
    private SimpleThreadDispatcher _threadDispatcher;

    // Debug
    private double _debugTimer = 0;
    private const double DebugInterval = 1.0; // Print debug info every second

    // Rendering
    private VertexPositionNormal[] _cubeVertices;
    private short[] _cubeIndices;
    private VertexPositionNormal[] _sphereVertices;
    private short[] _sphereIndices;

    // Camera
    private Microsoft.Xna.Framework.Vector3 _cameraPosition;
    private Microsoft.Xna.Framework.Vector3 _cameraTarget;
    private float _cameraDistance = 25f;
    private float _cameraAngleX = 0.5f;
    private float _cameraAngleY = XnaMathHelper.PiOver4;

    private MouseState _previousMouseState;
    private KeyboardState _previousKeyboardState;

    public Game1()
    {
        _graphics = new GraphicsDeviceManager(this);
        Content.RootDirectory = "Content";
        IsMouseVisible = true;

        _graphics.PreferredBackBufferWidth = 1280;
        _graphics.PreferredBackBufferHeight = 720;
    }

    protected override void Initialize()
    {
        // Initialize Bepu Physics
        _bufferPool = new BufferPool();
        _threadDispatcher = new SimpleThreadDispatcher(System.Environment.ProcessorCount);

        _simulation = Simulation.Create(_bufferPool, new NarrowPhaseCallbacks(), new PoseIntegratorCallbacks(new Vector3(0, -10, 0)), new SolveDescription(8, 1));

        // Create ground plane
        var groundShape = new Box(50, 1, 50);
        var groundShapeIndex = _simulation.Shapes.Add(groundShape);
        _simulation.Statics.Add(new StaticDescription(new Vector3(0, -0.5f, 0), groundShapeIndex));

        // Create pyramid of boxes
        CreateBoxPyramid();

        // Create rendering geometry
        CreateCubeGeometry();
        CreateSphereGeometry(16, 16);

        base.Initialize();
    }

    private void CreateBoxPyramid()
    {
        var boxShape = new Box(1, 1, 1);
        var boxShapeIndex = _simulation.Shapes.Add(boxShape);
        var boxInertia = boxShape.ComputeInertia(1);

        const int pyramidLevels = 6;
        for (int level = 0; level < pyramidLevels; level++)
        {
            int boxesPerSide = pyramidLevels - level;
            float yPos = level * 1.05f + 0.5f;

            for (int x = 0; x < boxesPerSide; x++)
            {
                for (int z = 0; z < boxesPerSide; z++)
                {
                    float xPos = (x - boxesPerSide / 2.0f) * 1.05f;
                    float zPos = (z - boxesPerSide / 2.0f) * 1.05f;

                    _simulation.Bodies.Add(BodyDescription.CreateDynamic(
                        new Vector3(xPos, yPos, zPos),
                        boxInertia,
                        boxShapeIndex,
                        0.01f));
                }
            }
        }
    }

    private void CreateCubeGeometry()
    {
        // Create 24 vertices (4 per face with proper normals)
        var vertices = new System.Collections.Generic.List<VertexPositionNormal>();
        var indices = new System.Collections.Generic.List<short>();

        // Front face (Z+)
        AddQuad(vertices, indices,
            new Microsoft.Xna.Framework.Vector3(-0.5f, -0.5f, 0.5f),
            new Microsoft.Xna.Framework.Vector3(0.5f, -0.5f, 0.5f),
            new Microsoft.Xna.Framework.Vector3(0.5f, 0.5f, 0.5f),
            new Microsoft.Xna.Framework.Vector3(-0.5f, 0.5f, 0.5f),
            new Microsoft.Xna.Framework.Vector3(0, 0, 1));

        // Back face (Z-)
        AddQuad(vertices, indices,
            new Microsoft.Xna.Framework.Vector3(0.5f, -0.5f, -0.5f),
            new Microsoft.Xna.Framework.Vector3(-0.5f, -0.5f, -0.5f),
            new Microsoft.Xna.Framework.Vector3(-0.5f, 0.5f, -0.5f),
            new Microsoft.Xna.Framework.Vector3(0.5f, 0.5f, -0.5f),
            new Microsoft.Xna.Framework.Vector3(0, 0, -1));

        // Left face (X-)
        AddQuad(vertices, indices,
            new Microsoft.Xna.Framework.Vector3(-0.5f, -0.5f, -0.5f),
            new Microsoft.Xna.Framework.Vector3(-0.5f, -0.5f, 0.5f),
            new Microsoft.Xna.Framework.Vector3(-0.5f, 0.5f, 0.5f),
            new Microsoft.Xna.Framework.Vector3(-0.5f, 0.5f, -0.5f),
            new Microsoft.Xna.Framework.Vector3(-1, 0, 0));

        // Right face (X+)
        AddQuad(vertices, indices,
            new Microsoft.Xna.Framework.Vector3(0.5f, -0.5f, 0.5f),
            new Microsoft.Xna.Framework.Vector3(0.5f, -0.5f, -0.5f),
            new Microsoft.Xna.Framework.Vector3(0.5f, 0.5f, -0.5f),
            new Microsoft.Xna.Framework.Vector3(0.5f, 0.5f, 0.5f),
            new Microsoft.Xna.Framework.Vector3(1, 0, 0));

        // Top face (Y+)
        AddQuad(vertices, indices,
            new Microsoft.Xna.Framework.Vector3(-0.5f, 0.5f, 0.5f),
            new Microsoft.Xna.Framework.Vector3(0.5f, 0.5f, 0.5f),
            new Microsoft.Xna.Framework.Vector3(0.5f, 0.5f, -0.5f),
            new Microsoft.Xna.Framework.Vector3(-0.5f, 0.5f, -0.5f),
            new Microsoft.Xna.Framework.Vector3(0, 1, 0));

        // Bottom face (Y-)
        AddQuad(vertices, indices,
            new Microsoft.Xna.Framework.Vector3(-0.5f, -0.5f, -0.5f),
            new Microsoft.Xna.Framework.Vector3(0.5f, -0.5f, -0.5f),
            new Microsoft.Xna.Framework.Vector3(0.5f, -0.5f, 0.5f),
            new Microsoft.Xna.Framework.Vector3(-0.5f, -0.5f, 0.5f),
            new Microsoft.Xna.Framework.Vector3(0, -1, 0));

        _cubeVertices = vertices.ToArray();
        _cubeIndices = indices.ToArray();
    }

    private void AddQuad(System.Collections.Generic.List<VertexPositionNormal> vertices, System.Collections.Generic.List<short> indices,
        Microsoft.Xna.Framework.Vector3 v0, Microsoft.Xna.Framework.Vector3 v1, Microsoft.Xna.Framework.Vector3 v2, Microsoft.Xna.Framework.Vector3 v3,
        Microsoft.Xna.Framework.Vector3 normal)
    {
        short baseIndex = (short)vertices.Count;

        vertices.Add(new VertexPositionNormal(v0, normal));
        vertices.Add(new VertexPositionNormal(v1, normal));
        vertices.Add(new VertexPositionNormal(v2, normal));
        vertices.Add(new VertexPositionNormal(v3, normal));

        // Counter-clockwise winding order
        indices.Add(baseIndex);
        indices.Add((short)(baseIndex + 2));
        indices.Add((short)(baseIndex + 1));

        indices.Add(baseIndex);
        indices.Add((short)(baseIndex + 3));
        indices.Add((short)(baseIndex + 2));
    }

    private void CreateSphereGeometry(int slices, int stacks)
    {
        var vertices = new System.Collections.Generic.List<VertexPositionNormal>();
        var indices = new System.Collections.Generic.List<short>();

        float radius = 0.5f;

        // Generate vertices with normals
        for (int stack = 0; stack <= stacks; stack++)
        {
            float phi = XnaMathHelper.Pi * stack / stacks;
            for (int slice = 0; slice <= slices; slice++)
            {
                float theta = XnaMathHelper.TwoPi * slice / slices;

                var pos = new Microsoft.Xna.Framework.Vector3(
                    radius * (float)(System.Math.Sin(phi) * System.Math.Cos(theta)),
                    radius * (float)System.Math.Cos(phi),
                    radius * (float)(System.Math.Sin(phi) * System.Math.Sin(theta))
                );

                // Normal for a sphere is just the normalized position
                var normal = Microsoft.Xna.Framework.Vector3.Normalize(pos);

                vertices.Add(new VertexPositionNormal(pos, normal));
            }
        }

        // Generate indices (counter-clockwise winding)
        for (int stack = 0; stack < stacks; stack++)
        {
            for (int slice = 0; slice < slices; slice++)
            {
                short first = (short)(stack * (slices + 1) + slice);
                short second = (short)(first + slices + 1);

                indices.Add(first);
                indices.Add((short)(first + 1));
                indices.Add(second);

                indices.Add(second);
                indices.Add((short)(first + 1));
                indices.Add((short)(second + 1));
            }
        }

        _sphereVertices = vertices.ToArray();
        _sphereIndices = indices.ToArray();
    }

    protected override void LoadContent()
    {
        _spriteBatch = new SpriteBatch(GraphicsDevice);

        _effect = new BasicEffect(GraphicsDevice)
        {
            VertexColorEnabled = false,
            LightingEnabled = true,
            PreferPerPixelLighting = true,
            AmbientLightColor = new Microsoft.Xna.Framework.Vector3(0.3f, 0.3f, 0.3f),
            DirectionalLight0 =
            {
                Enabled = true,
                DiffuseColor = new Microsoft.Xna.Framework.Vector3(0.8f, 0.8f, 0.8f),
                Direction = Microsoft.Xna.Framework.Vector3.Normalize(new Microsoft.Xna.Framework.Vector3(-1, -1, -1)),
                SpecularColor = new Microsoft.Xna.Framework.Vector3(0.5f, 0.5f, 0.5f)
            }
        };

        System.Console.WriteLine("=== Fallen Tribes - Debug Mode ===");
        System.Console.WriteLine("Game initialized successfully");
    }

    protected override void Update(GameTime gameTime)
    {
        var keyboardState = Keyboard.GetState();
        var mouseState = Mouse.GetState();

        if (keyboardState.IsKeyDown(Keys.Escape))
            Exit();

        // Camera controls with mouse
        if (mouseState.RightButton == ButtonState.Pressed)
        {
            if (_previousMouseState.RightButton == ButtonState.Pressed)
            {
                float deltaX = (mouseState.X - _previousMouseState.X) * 0.01f;
                float deltaY = (mouseState.Y - _previousMouseState.Y) * 0.01f;

                _cameraAngleY -= deltaX;
                _cameraAngleX -= deltaY;
                _cameraAngleX = XnaMathHelper.Clamp(_cameraAngleX, -XnaMathHelper.PiOver2 + 0.1f, XnaMathHelper.PiOver2 - 0.1f);
            }
        }

        // Zoom with mouse wheel
        if (mouseState.ScrollWheelValue != _previousMouseState.ScrollWheelValue)
        {
            _cameraDistance -= (mouseState.ScrollWheelValue - _previousMouseState.ScrollWheelValue) * 0.01f;
            _cameraDistance = XnaMathHelper.Clamp(_cameraDistance, 5f, 100f);
        }

        // Shoot sphere on left click
        if (mouseState.LeftButton == ButtonState.Pressed && _previousMouseState.LeftButton == ButtonState.Released)
        {
            ShootSphere();
        }

        // Update camera position
        _cameraPosition = new Microsoft.Xna.Framework.Vector3(
            (float)(System.Math.Cos(_cameraAngleY) * System.Math.Cos(_cameraAngleX)) * _cameraDistance,
            (float)System.Math.Sin(_cameraAngleX) * _cameraDistance,
            (float)(System.Math.Sin(_cameraAngleY) * System.Math.Cos(_cameraAngleX)) * _cameraDistance
        );

        _cameraTarget = Microsoft.Xna.Framework.Vector3.Zero;

        // Update physics
        _simulation.Timestep(1 / 60f, _threadDispatcher);

        // Debug output
        _debugTimer += gameTime.ElapsedGameTime.TotalSeconds;
        if (_debugTimer >= DebugInterval)
        {
            _debugTimer = 0;
            int totalBodies = _simulation.Bodies.ActiveSet.Count + _simulation.Bodies.Sets.Length;
            System.Console.WriteLine($"[DEBUG] Active Bodies: {_simulation.Bodies.ActiveSet.Count}, Camera Distance: {_cameraDistance:F2}, FPS: {1.0 / gameTime.ElapsedGameTime.TotalSeconds:F0}");
        }

        _previousMouseState = mouseState;
        _previousKeyboardState = keyboardState;

        base.Update(gameTime);
    }

    private void ShootSphere()
    {
        var sphereShape = new Sphere(0.5f);
        var sphereShapeIndex = _simulation.Shapes.Add(sphereShape);
        var sphereInertia = sphereShape.ComputeInertia(5);

        var shootDirection = Microsoft.Xna.Framework.Vector3.Normalize(_cameraTarget - _cameraPosition);
        var startPos = _cameraPosition + shootDirection * 2;

        var bodyDescription = BodyDescription.CreateDynamic(
            new Vector3(startPos.X, startPos.Y, startPos.Z),
            new BodyVelocity(new Vector3(shootDirection.X * 50, shootDirection.Y * 50, shootDirection.Z * 50)),
            sphereInertia,
            sphereShapeIndex,
            0.01f);

        var handle = _simulation.Bodies.Add(bodyDescription);
        System.Console.WriteLine($"[SHOOT] Sphere fired! Handle: {handle.Value}, Direction: ({shootDirection.X:F2}, {shootDirection.Y:F2}, {shootDirection.Z:F2})");
    }

    protected override void Draw(GameTime gameTime)
    {
        GraphicsDevice.Clear(Color.CornflowerBlue);

        // Set up camera
        var view = Microsoft.Xna.Framework.Matrix.CreateLookAt(_cameraPosition, _cameraTarget, Microsoft.Xna.Framework.Vector3.Up);
        var projection = Microsoft.Xna.Framework.Matrix.CreatePerspectiveFieldOfView(
            XnaMathHelper.ToRadians(45),
            GraphicsDevice.Viewport.AspectRatio,
            0.1f,
            1000f
        );

        _effect.View = view;
        _effect.Projection = projection;

        // Draw ground
        DrawBox(new Vector3(0, -0.5f, 0), System.Numerics.Quaternion.Identity, new Vector3(50, 1, 50), Color.DarkGreen);

        // Draw all dynamic bodies (active and sleeping)
        for (int setIndex = 0; setIndex < _simulation.Bodies.Sets.Length; setIndex++)
        {
            ref var set = ref _simulation.Bodies.Sets[setIndex];
            if (!set.Allocated)
                continue;

            for (int bodyIndex = 0; bodyIndex < set.Count; bodyIndex++)
            {
                var bodyHandle = set.IndexToHandle[bodyIndex];
                var bodyReference = _simulation.Bodies[bodyHandle];
                var shapeIndex = bodyReference.Collidable.Shape;

                if (shapeIndex.Type == Box.Id)
                {
                    var box = _simulation.Shapes.GetShape<Box>(shapeIndex.Index);
                    DrawBox(bodyReference.Pose.Position, bodyReference.Pose.Orientation,
                        new Vector3(box.Width, box.Height, box.Length), Color.LightBlue);
                }
                else if (shapeIndex.Type == Sphere.Id)
                {
                    var sphere = _simulation.Shapes.GetShape<Sphere>(shapeIndex.Index);
                    DrawSphere(bodyReference.Pose.Position, sphere.Radius, Color.Red);
                }
            }
        }

        base.Draw(gameTime);
    }

    private void DrawBox(Vector3 position, System.Numerics.Quaternion orientation, Vector3 size, Color color)
    {
        // Convert Bepu types to XNA types
        var xnaPos = new Microsoft.Xna.Framework.Vector3(position.X, position.Y, position.Z);
        var xnaQuat = new XnaQuaternion(orientation.X, orientation.Y, orientation.Z, orientation.W);

        var world = Microsoft.Xna.Framework.Matrix.CreateScale(size.X, size.Y, size.Z) *
                   Microsoft.Xna.Framework.Matrix.CreateFromQuaternion(xnaQuat) *
                   Microsoft.Xna.Framework.Matrix.CreateTranslation(xnaPos);

        _effect.World = world;
        _effect.DiffuseColor = color.ToVector3();

        foreach (var pass in _effect.CurrentTechnique.Passes)
        {
            pass.Apply();
            GraphicsDevice.DrawUserIndexedPrimitives(
                PrimitiveType.TriangleList,
                _cubeVertices,
                0,
                _cubeVertices.Length,
                _cubeIndices,
                0,
                _cubeIndices.Length / 3
            );
        }
    }

    private void DrawSphere(Vector3 position, float radius, Color color)
    {
        var xnaPos = new Microsoft.Xna.Framework.Vector3(position.X, position.Y, position.Z);
        var world = Microsoft.Xna.Framework.Matrix.CreateScale(radius * 2) *
                   Microsoft.Xna.Framework.Matrix.CreateTranslation(xnaPos);

        _effect.World = world;
        _effect.DiffuseColor = color.ToVector3();

        foreach (var pass in _effect.CurrentTechnique.Passes)
        {
            pass.Apply();
            GraphicsDevice.DrawUserIndexedPrimitives(
                PrimitiveType.TriangleList,
                _sphereVertices,
                0,
                _sphereVertices.Length,
                _sphereIndices,
                0,
                _sphereIndices.Length / 3
            );
        }
    }

    protected override void Dispose(bool disposing)
    {
        if (disposing)
        {
            _simulation?.Dispose();
            _bufferPool?.Clear();
            _threadDispatcher?.Dispose();
            _effect?.Dispose();
        }
        base.Dispose(disposing);
    }
}

// Required Bepu callbacks
struct NarrowPhaseCallbacks : INarrowPhaseCallbacks
{
    public void Initialize(Simulation simulation) { }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool AllowContactGeneration(int workerIndex, CollidableReference a, CollidableReference b, ref float speculativeMargin)
    {
        return true;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool AllowContactGeneration(int workerIndex, CollidablePair pair, int childIndexA, int childIndexB)
    {
        return true;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool ConfigureContactManifold<TManifold>(int workerIndex, CollidablePair pair, ref TManifold manifold, out PairMaterialProperties pairMaterial) where TManifold : unmanaged, IContactManifold<TManifold>
    {
        pairMaterial.FrictionCoefficient = 0.5f;
        pairMaterial.MaximumRecoveryVelocity = 2f;
        pairMaterial.SpringSettings = new SpringSettings(30f, 1f);
        return true;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool ConfigureContactManifold(int workerIndex, CollidablePair pair, int childIndexA, int childIndexB, ref ConvexContactManifold manifold)
    {
        return true;
    }

    public void Dispose() { }
}

struct PoseIntegratorCallbacks : IPoseIntegratorCallbacks
{
    public Vector3 Gravity;

    public PoseIntegratorCallbacks(Vector3 gravity)
    {
        Gravity = gravity;
    }

    public readonly AngularIntegrationMode AngularIntegrationMode => AngularIntegrationMode.Nonconserving;
    public readonly bool AllowSubstepsForUnconstrainedBodies => false;
    public readonly bool IntegrateVelocityForKinematics => false;

    public void Initialize(Simulation simulation) { }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void PrepareForIntegration(float dt) { }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void IntegrateVelocity(Vector<int> bodyIndices, Vector3Wide position, QuaternionWide orientation, BodyInertiaWide localInertia, Vector<int> integrationMask, int workerIndex, Vector<float> dt, ref BodyVelocityWide velocity)
    {
        velocity.Linear.X += Gravity.X * dt;
        velocity.Linear.Y += Gravity.Y * dt;
        velocity.Linear.Z += Gravity.Z * dt;
    }
}

class SimpleThreadDispatcher : IThreadDispatcher
{
    private readonly int _threadCount;
    private System.Threading.Tasks.Task[] _workers;
    private readonly BufferPool[] _threadPools;

    public int ThreadCount => _threadCount;

    public SimpleThreadDispatcher(int threadCount)
    {
        _threadCount = threadCount;
        _threadPools = new BufferPool[threadCount];
        for (int i = 0; i < threadCount; i++)
        {
            _threadPools[i] = new BufferPool();
        }
    }

    public void DispatchWorkers(System.Action<int> workerBody, int maximumWorkerCount)
    {
        int workerCount = System.Math.Min(maximumWorkerCount, _threadCount);
        _workers = new System.Threading.Tasks.Task[workerCount];

        for (int i = 0; i < workerCount; i++)
        {
            int workerIndex = i;
            _workers[i] = System.Threading.Tasks.Task.Run(() => workerBody(workerIndex));
        }

        System.Threading.Tasks.Task.WaitAll(_workers);
    }

    public BufferPool GetThreadMemoryPool(int workerIndex)
    {
        return _threadPools[workerIndex];
    }

    public void Dispose()
    {
        for (int i = 0; i < _threadPools.Length; i++)
        {
            _threadPools[i]?.Clear();
        }
    }
}
